<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Generate level
//Resize
room_width = (CELL_WIDTH)*64
room_height= (CELL_HEIGHT)*48

//Set the grid width and height

var width = room_width div CELL_WIDTH;
var height = room_height div CELL_HEIGHT;

//create grid

grid= ds_grid_create(width,height);

//fill the grid
ds_grid_set_region(grid, 0, 0, width-1, height-1, VOID);

//randomize generation (or seed generation SHOULD BE IMPLEMENTED here)
randomize();

//create the controller in the center of the grid
var cx= width div 2;
var cy= height div 2;


//give the controller a random direction

//0 is right 1 is up 2 is left 3 is down 
var cdir= irandom(3); 

//the odds variable for changing direction
var odds=1;

//create the level using 1000 steps
repeat (800){
    //place a floor tile at the controller position\
    grid[# cx, cy] = FLOOR;
    grid[# cx+1, cy] = FLOOR;
    grid[# cx, cy+1] = FLOOR;
    grid[# cx+1, cy+1] = FLOOR;
    
    //square diagonal top +2 everywhere
    grid[# cx+2, cy+2] = FLOOR;
    grid[# cx+3, cy+2] = FLOOR;
    grid[# cx+2, cy+3] = FLOOR;
    grid[# cx+3, cy+3] = FLOOR;
    
    //square to the right +2 to x values
    grid[# cx+2, cy] = FLOOR;
    grid[# cx+3, cy] = FLOOR;
    grid[# cx+2, cy+1] = FLOOR;
    grid[# cx+3, cy+1] = FLOOR;
    
    //square to the top +2 to y values
    grid[# cx, cy+2] = FLOOR;
    grid[# cx+1, cy+2] = FLOOR;
    grid[# cx, cy+3] = FLOOR;
    grid[# cx+1, cy+3] = FLOOR;
    
    //randomize the direction of the controller
    if (irandom(odds) == odds) {
        cdir=irandom(3);
    }
    //move the controller
    var xdir = lengthdir_x(2,cdir*90);
    var ydir = lengthdir_y(2,cdir*90);
    cx += xdir;
    cy += ydir;
    
    // grid limits for room creation
    cx = clamp(cx, 1, width-5);
    cy = clamp(cy, 1, height-5);
    
}
//surround floor tiles with walls
for (var yy = 1 ; yy &lt; height-1; yy++) {
    for (var xx = 1; xx&lt; width-1; xx++){
        if (grid[# xx, yy] == FLOOR) {
        //check for walls
            if (grid[# xx+1, yy] != FLOOR) grid[# xx+1,yy] = WALL; //right
            if (grid[# xx-1, yy] != FLOOR) grid[# xx-1,yy] = WALL; //left
            if (grid[# xx, yy+1] != FLOOR) grid[# xx,yy+1] = WALL; //down
            if (grid[# xx, yy-1] != FLOOR) grid[# xx,yy-1] = WALL; //up
        }
    
    }

}

floorNum = 0;
//draw the level using the grid we created
for (var yy=0; yy&lt;height ; yy++) {
    for (var xx = 0; xx&lt;width ;xx++){
        if (grid[# xx,yy] ==WALL) {
            //tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 0)
            wall = instance_create( xx*CELL_WIDTH, yy*CELL_HEIGHT, Obstacle);
            wall.visible = true;
            wall.sprite_index = sprWall;
        }
    }
}

for (var yy=0; yy&lt;height ; yy++) {
    for (var xx = 0; xx&lt;width ;xx++){
        if (grid[# xx, yy] ==FLOOR){
            tile_add(bg_floor, 0 ,0,CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 1);
            floorNum++;
        }
    }
}
gNum = floorNum/GUARDNUM;
f = 0;
while (gNum &gt; 0)
for (var yy=0; yy&lt;height ; yy++) {
    for (var xx = 0; xx&lt;width ;xx++){
        if (grid[# xx, yy] ==FLOOR){
            f++;
            if (f mod GUARDNUM == 0 &amp;&amp; !place_meeting(xx*CELL_WIDTH + 8, yy*CELL_HEIGHT + 8, Obstacle)){
                instance_create(xx*CELL_WIDTH + 8, yy*CELL_HEIGHT + 8, Guard);
                gNum--;
            }
        }
    }
}

///--------
wall = cornerRaycast(room_width, 0, 0);
if (instance_exists(wall)){
    topLeft = wall;
}
wall = cornerRaycast(room_width, room_width, 0);
if (instance_exists(wall)){
    topRight = wall;
}
wall = instance_nearest(0, room_height, Obstacle);//cornerRaycast(room_width, 0, room_height);
if (instance_exists(wall)){
    bottomLeft = wall;
}
wall = instance_nearest(room_width, room_height, Obstacle); //cornerRaycast(room_width, room_width, room_height);
if (instance_exists(wall)){
    bottomRight = wall;
}


//tile_add(background4, 0 ,0,CELL_WIDTH, CELL_HEIGHT, topLeft.x, topLeft.y, 1);
//tile_add(background4, 0 ,0,CELL_WIDTH, CELL_HEIGHT, topRight.x, topRight.y, 1);
//tile_add(background5, 0 ,0,CELL_WIDTH, CELL_HEIGHT, bottomLeft.x, bottomLeft.y, 1);
//tile_add(background5, 0 ,0,CELL_WIDTH, CELL_HEIGHT, bottomRight.x, bottomRight.y, 1);



array[0]=topLeft;
array[1]=topRight;
array[2]=bottomLeft;
array[3]=bottomRight;
var startWall=topLeft;
var endWall=topLeft;

for (var i = 0 ; i &lt;= 3; i++) {
    for (var j=0; j&lt;=3 ; j++){  
   // show_message(string(i) + " " + string(j) + " " + string(grid_distance(array[i], array[j])));
        if (grid_distance(array[i], array[j]) &gt;  (grid_distance(startWall,endWall))){
            
            startWall=array[i];
            endWall=array[j];
        }
    }  
}

tile_add(background4, 0 ,0,CELL_WIDTH, CELL_HEIGHT, startWall.x, startWall.y, 1);
tile_add(background5, 0 ,0,CELL_WIDTH, CELL_HEIGHT, endWall.x, endWall.y, 1);

path = path_get(startWall,endWall);
xx = path_get_point_x(path, 2);
yy = path_get_point_y(path, 2);

instance_create(xx, yy, Children);
instance_create(room_width/2, room_height/2, Player);

instance_create(endWall.x, endWall.y, Escape);


//show_message(string(grid_distance(topLeft, topRight)));



//------------------------------------------------------------------------------------
//adding things in map

var emptySpace=0;



for (var yy=1; yy&lt;height-12 ; yy++) {
    for (var xx = 1; xx&lt;width-12 ;xx++){
        for (var i=0; i&lt;12; i++){  
            for (var j=0; j&lt;12; j++){
                if (grid[# xx+i, yy+j] ==FLOOR) emptySpace++;
            }   
        }
        if (emptySpace==144){
           // show_message("EMPTY SPACE DISCOVERED! " + string(emptySpace));
            //grid[# xx+4,yy+4] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+4)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, 1);
            wall=instance_create((xx+4)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, Obstacle);
            
            
           // grid[# xx+5,yy+4] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+5)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, 1);
            wall=instance_create((xx+5)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+6,yy+4] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+6)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, 1);
            wall=instance_create((xx+6)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+7,yy+4] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+7)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, 1);
            wall=instance_create((xx+7)*CELL_WIDTH, (yy+4)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+7,yy+5] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+7)*CELL_WIDTH, (yy+5)*CELL_HEIGHT, 1);
            wall=instance_create((xx+7)*CELL_WIDTH, (yy+5)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+7,yy+6] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+7)*CELL_WIDTH, (yy+6)*CELL_HEIGHT, 1);
            wall=instance_create((xx+7)*CELL_WIDTH, (yy+6)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+7,yy+7] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+7)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, 1);
            wall=instance_create((xx+7)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+6,yy+7] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+6)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, 1);
            wall=instance_create((xx+6)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+5,yy+7] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+5)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, 1);
            wall=instance_create((xx+5)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+4,yy+7] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+4)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, 1);
            wall=instance_create((xx+4)*CELL_WIDTH, (yy+7)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+4,yy+6] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+4)*CELL_WIDTH, (yy+6)*CELL_HEIGHT, 1);
            wall=instance_create((xx+4)*CELL_WIDTH, (yy+6)*CELL_HEIGHT, Obstacle);
            
            
            //grid[# xx+4,yy+5] = WALL;
            tile_add(bg_wall, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+4)*CELL_WIDTH, (yy+5)*CELL_HEIGHT, 1);
            wall=instance_create((xx+4)*CELL_WIDTH, (yy+5)*CELL_HEIGHT, Obstacle);
            
            
            grid[# xx+5,yy+5] = VOID;
            tile_add(bg_grass, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+5)*CELL_WIDTH, (yy+5)*CELL_HEIGHT, 1);
            grid[# xx+5,yy+6] = VOID;
            tile_add(bg_grass, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+5)*CELL_WIDTH, (yy+6)*CELL_HEIGHT, 1);
            grid[# xx+6,yy+5] = VOID;
            tile_add(bg_grass, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+6)*CELL_WIDTH, (yy+5)*CELL_HEIGHT, 1);
            grid[# xx+6,yy+6] = VOID;
            tile_add(bg_grass, 0 ,0,CELL_WIDTH, CELL_HEIGHT, (xx+6)*CELL_WIDTH, (yy+6)*CELL_HEIGHT, 1);
            
        }else {
            emptySpace=0;
        }
        
    }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="17">
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
